From ac2b3aa32272d2fe9240e27927da7cb752802c48 Mon Sep 17 00:00:00 2001
From: fwarmerdam <fwarmerdam>
Date: Fri, 2 Nov 2012 05:13:24 +0000
Subject: [PATCH] fix zero size buffer exploit (CVE-2012-4564) in ppm2tiff

---

diff --git a/tools/ppm2tiff.c b/tools/ppm2tiff.c
index f78d5d4..1a6d7f6 100644
--- a/tools/ppm2tiff.c
+++ b/tools/ppm2tiff.c
@@ -1,4 +1,4 @@
-/* $Id: ppm2tiff.c,v 1.16 2010-04-10 19:22:34 bfriesen Exp $ */
+/* $Id: ppm2tiff.c,v 1.17 2012-11-02 05:13:24 fwarmerdam Exp $ */
 
 /*
  * Copyright (c) 1991-1997 Sam Leffler
@@ -89,6 +89,7 @@ main(int argc, char* argv[])
 	int c;
 	extern int optind;
 	extern char* optarg;
+	tmsize_t scanline_size;
 
 	if (argc < 2) {
 	    fprintf(stderr, "%s: Too few arguments\n", argv[0]);
@@ -237,8 +238,16 @@ main(int argc, char* argv[])
 	}
 	if (TIFFScanlineSize(out) > linebytes)
 		buf = (unsigned char *)_TIFFmalloc(linebytes);
-	else
-		buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));
+	else {
+		scanline_size = TIFFScanlineSize(out);
+		if (scanline_size != 0)
+			buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));
+		else {
+			fprintf(stderr, "%s: scanline size overflow\n",infile);
+			(void) TIFFClose(out);
+			exit(-2);					
+			}
+		}
 	if (resolution > 0) {
 		TIFFSetField(out, TIFFTAG_XRESOLUTION, resolution);
 		TIFFSetField(out, TIFFTAG_YRESOLUTION, resolution);
-- 
1.8.3.rc3

From a88a041eb23156ae3e76355802802c6dbdd8a8f4 Mon Sep 17 00:00:00 2001
From: tgl <tgl>
Date: Mon, 10 Dec 2012 18:19:11 +0000
Subject: [PATCH] Improve previous patch for CVE-2012-4564.

---

diff --git a/tools/ppm2tiff.c b/tools/ppm2tiff.c
index 1a6d7f6..70f74be 100644
--- a/tools/ppm2tiff.c
+++ b/tools/ppm2tiff.c
@@ -1,4 +1,4 @@
-/* $Id: ppm2tiff.c,v 1.17 2012-11-02 05:13:24 fwarmerdam Exp $ */
+/* $Id: ppm2tiff.c,v 1.18 2012-12-10 18:19:11 tgl Exp $ */
 
 /*
  * Copyright (c) 1991-1997 Sam Leffler
@@ -72,6 +72,17 @@ BadPPM(char* file)
 	exit(-2);
 }
 
+static tmsize_t
+multiply_ms(tmsize_t m1, tmsize_t m2)
+{
+	tmsize_t bytes = m1 * m2;
+
+	if (m1 && bytes / m1 != m2)
+		bytes = 0;
+
+	return bytes;
+}
+
 int
 main(int argc, char* argv[])
 {
@@ -79,7 +90,7 @@ main(int argc, char* argv[])
 	uint32 rowsperstrip = (uint32) -1;
 	double resolution = -1;
 	unsigned char *buf = NULL;
-	tsize_t linebytes = 0;
+	tmsize_t linebytes = 0;
 	uint16 spp = 1;
 	uint16 bpp = 8;
 	TIFF *out;
@@ -222,7 +233,8 @@ main(int argc, char* argv[])
 	}
 	switch (bpp) {
 		case 1:
-			linebytes = (spp * w + (8 - 1)) / 8;
+			/* if round-up overflows, result will be zero, OK */
+			linebytes = (multiply_ms(spp, w) + (8 - 1)) / 8;
 			if (rowsperstrip == (uint32) -1) {
 				TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, h);
 			} else {
@@ -231,23 +243,31 @@ main(int argc, char* argv[])
 			}
 			break;
 		case 8:
-			linebytes = spp * w;
+			linebytes = multiply_ms(spp, w);
 			TIFFSetField(out, TIFFTAG_ROWSPERSTRIP,
 			    TIFFDefaultStripSize(out, rowsperstrip));
 			break;
 	}
-	if (TIFFScanlineSize(out) > linebytes)
+	if (linebytes == 0) {
+		fprintf(stderr, "%s: scanline size overflow\n", infile);
+		(void) TIFFClose(out);
+		exit(-2);					
+	}
+	scanline_size = TIFFScanlineSize(out);
+	if (scanline_size == 0) {
+		/* overflow - TIFFScanlineSize already printed a message */
+		(void) TIFFClose(out);
+		exit(-2);					
+	}
+	if (scanline_size < linebytes)
 		buf = (unsigned char *)_TIFFmalloc(linebytes);
-	else {
-		scanline_size = TIFFScanlineSize(out);
-		if (scanline_size != 0)
-			buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));
-		else {
-			fprintf(stderr, "%s: scanline size overflow\n",infile);
-			(void) TIFFClose(out);
-			exit(-2);					
-			}
-		}
+	else
+		buf = (unsigned char *)_TIFFmalloc(scanline_size);
+	if (buf == NULL) {
+		fprintf(stderr, "%s: Not enough memory\n", infile);
+		(void) TIFFClose(out);
+		exit(-2);
+	}
 	if (resolution > 0) {
 		TIFFSetField(out, TIFFTAG_XRESOLUTION, resolution);
 		TIFFSetField(out, TIFFTAG_YRESOLUTION, resolution);
-- 
1.8.3.rc3

